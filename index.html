<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>英検リスニング演習 Studio (Local DB)</title>

  <!-- React & ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <!-- Babel (JSX Compiler) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    /* Custom Scrollbar for better UI */
    .custom-scrollbar::-webkit-scrollbar {
      width: 8px;
    }

    .custom-scrollbar::-webkit-scrollbar-track {
      background: #f1f1f1;
    }

    .custom-scrollbar::-webkit-scrollbar-thumb {
      background: #c1c1c1;
      border-radius: 4px;
    }

    .custom-scrollbar::-webkit-scrollbar-thumb:hover {
      background: #a8a8a8;
    }

    /* Animation utilities */
    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    .animate-fadeIn {
      animation: fadeIn 0.2s ease-out;
    }
  </style>
</head>

<body class="bg-gray-100 text-gray-800">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useRef, useEffect, useCallback } = React;

    // --- Icons (Inline SVG Components to avoid external dependencies) ---
    const IconWrapper = ({ children, size = 24, className = "", ...props }) => (
      <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>
        {children}
      </svg>
    );

    const Icons = {
      Play: (p) => <IconWrapper {...p}><polygon points="5 3 19 12 5 21 5 3"></polygon></IconWrapper>,
      Pause: (p) => <IconWrapper {...p}><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></IconWrapper>,
      Upload: (p) => <IconWrapper {...p}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></IconWrapper>,
      Trash2: (p) => <IconWrapper {...p}><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></IconWrapper>,
      Volume2: (p) => <IconWrapper {...p}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></IconWrapper>,
      PlusCircle: (p) => <IconWrapper {...p}><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></IconWrapper>,
      CheckCircle: (p) => <IconWrapper {...p}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></IconWrapper>,
      ChevronLeft: (p) => <IconWrapper {...p}><polyline points="15 18 9 12 15 6"></polyline></IconWrapper>,
      ChevronRight: (p) => <IconWrapper {...p}><polyline points="9 18 15 12 9 6"></polyline></IconWrapper>,
      FileText: (p) => <IconWrapper {...p}><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></IconWrapper>,
      Layers: (p) => <IconWrapper {...p}><polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline></IconWrapper>,
      X: (p) => <IconWrapper {...p}><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></IconWrapper>,
      Maximize2: (p) => <IconWrapper {...p}><polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line></IconWrapper>,
      RotateCcw: (p) => <IconWrapper {...p}><polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path></IconWrapper>,
      RotateCw: (p) => <IconWrapper {...p}><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></IconWrapper>,
      Download: (p) => <IconWrapper {...p}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></IconWrapper>,
      Save: (p) => <IconWrapper {...p}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></IconWrapper>,
      Gauge: (p) => <IconWrapper {...p}><path d="m12 14 4-4"></path><path d="M3.34 19a10 10 0 1 1 17.32 0"></path></IconWrapper>,
      Home: (p) => <IconWrapper {...p}><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></IconWrapper>,
      Database: (p) => <IconWrapper {...p}><ellipse cx="12" cy="5" rx="9" ry="3"></ellipse><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path></IconWrapper>,
      Clock: (p) => <IconWrapper {...p}><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></IconWrapper>,
      ArrowLeft: (p) => <IconWrapper {...p}><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></IconWrapper>,
      Scissors: (p) => <IconWrapper {...p}><circle cx="6" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><line x1="20" y1="4" x2="8.12" y2="15.88"></line><line x1="14.47" y1="14.48" x2="20" y2="20"></line><line x1="8.12" y1="8.12" x2="12" y2="12"></line></IconWrapper>,
      FolderOpen: (p) => <IconWrapper {...p}><path d="m6 14 1.45-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-3.25 7a2 2 0 0 1-1.94 1.5H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H20a2 2 0 0 1 2 2v2"></path></IconWrapper>
    };

    const {
      Play, Pause, Upload, Trash2, Volume2, PlusCircle, CheckCircle,
      ChevronLeft, ChevronRight, FileText, Layers, X,
      Maximize2, RotateCcw, RotateCw, Download, Save, Gauge,
      Home, Database, Clock, ArrowLeft, Scissors, FolderOpen
    } = Icons;

    // --- Server Assets Configuration ---
    const SERVER_ASSETS = {
      json: './assets/level4/2025-2/data.json',
      projectTitle: '2025年度 第2回 英検4級 (本会場)',
      audio: [
        { name: 'Part 1 (No.1-10)', url: './assets/level4/2025-2/part1.mp3' },
        { name: 'Part 2 (No.11-20)', url: './assets/level4/2025-2/part2.mp3' },
        { name: 'Part 3 (No.21-30)', url: './assets/level4/2025-2/part3.mp3' }
      ]
    };

    // --- IndexedDB Helper Functions ---
    const DB_NAME = 'EikenStudioDB';
    const DB_VERSION = 1;
    const STORE_NAME = 'projects';

    const initDB = () => {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = (e) => reject(e.target.error);
        request.onsuccess = (e) => resolve(e.target.result);
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            const store = db.createObjectStore(STORE_NAME, { keyPath: 'id' });
            store.createIndex('updatedAt', 'updatedAt', { unique: false });
          }
        };
      });
    };

    const saveProjectToDB = async (project) => {
      const db = await initDB();
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.put(project);
        request.onsuccess = () => resolve(request.result);
        request.onerror = (e) => reject(e.target.error);
      });
    };

    const getAllProjectsMeta = async () => {
      const db = await initDB();
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.getAll();
        request.onsuccess = () => {
          const projects = request.result.map(p => ({
            id: p.id,
            title: p.title,
            updatedAt: p.updatedAt,
            pagesCount: p.pages.length,
            hasAudio: !!p.audio
          })).sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
          resolve(projects);
        };
        request.onerror = (e) => reject(e.target.error);
      });
    };

    const getProjectFromDB = async (id) => {
      const db = await initDB();
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get(id);
        request.onsuccess = () => resolve(request.result);
        request.onerror = (e) => reject(e.target.error);
      });
    };

    const deleteProjectFromDB = async (id) => {
      const db = await initDB();
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.delete(id);
        request.onsuccess = () => resolve();
        request.onerror = (e) => reject(e.target.error);
      });
    };

    // --- Main App Component ---

    const App = () => {
      // --- State Management ---
      const [isStudentMode] = useState(() => new URLSearchParams(window.location.search).has('student'));
      const [mode, setMode] = useState(isStudentMode ? 'library' : 'library');
      const [isLoading, setIsLoading] = useState(false);
      const [localProjects, setLocalProjects] = useState([]);
      const [remoteProjects, setRemoteProjects] = useState([]);

      // Current Project Metadata
      const [projectId, setProjectId] = useState(null);
      const [projectTitle, setProjectTitle] = useState("無題のプロジェクト");
      const [currentAudioConfig, setCurrentAudioConfig] = useState(null);

      // Pages & Audio
      const [pages, setPages] = useState([]);
      const [currentPageIndex, setCurrentPageIndex] = useState(0);
      const [audioSrc, setAudioSrc] = useState(null);
      const [audioFileName, setAudioFileName] = useState(null);

      // Markers
      const [markers, setMarkers] = useState([]);
      const [selectedMarkerId, setSelectedMarkerId] = useState(null);

      // Interaction
      const [interactionState, setInteractionState] = useState({
        type: null, markerId: null, startX: 0, startY: 0, initialData: null
      });
      const [isDraggingOver, setIsDraggingOver] = useState(false);

      // Audio Playback
      const [isPlaying, setIsPlaying] = useState(false);
      const [playbackRate, setPlaybackRate] = useState(1.0);
      const [currentMarkerId, setCurrentMarkerId] = useState(null);
      const [currentTime, setCurrentTime] = useState(0);
      const [duration, setDuration] = useState(0);

      const audioRef = useRef(null);
      const imageContainerRef = useRef(null);
      const audioCache = useRef({});
      const pendingPlayMarker = useRef(null);

      // --- Initial Load (Library) ---
      useEffect(() => {
        if (mode === 'library') {
          refreshLibrary();
          fetchRemoteCatalog();
        }
      }, [mode]);

      const fetchRemoteCatalog = async () => {
        try {
          const res = await fetch('./projects_catalog.json');
          if (res.ok) {
            const data = await res.json();
            setRemoteProjects(data);
          }
        } catch (e) { console.error("Catalog load failed", e); }
      };

      const importRemoteProject = async (pMeta) => {
        setIsLoading(true);
        try {
          // Build URL
          const jsonUrl = pMeta.dir ? `${pMeta.dir}/${pMeta.json}` : pMeta.json;

          const res = await fetch(jsonUrl);
          if (!res.ok) throw new Error(`Data not found (${res.status})`);

          const data = await res.json();

          // Check/Delete existing
          try { await deleteProjectFromDB(pMeta.id); } catch (e) { }

          const pagesForDB = data.pages ? await Promise.all(data.pages.map(async (p) => {
            const r = await fetch(p.src);
            const b = await r.blob();
            return { id: p.id, name: p.name, blob: b };
          })) : [];

          const projectData = {
            id: pMeta.id,
            title: pMeta.title,
            updatedAt: new Date().toISOString(),
            markers: data.markers || [],
            pages: pagesForDB,
            audio: null,
            audioConfig: {
              baseDir: pMeta.dir,
              tracks: pMeta.audio
            }
          };

          await saveProjectToDB(projectData);
          await refreshLibrary();

          handleOpenProject(pMeta.id);
          if (isStudentMode) alert("教材を読み込みました。");
        } catch (err) {
          console.error("Project load failed", err);
          alert("読み込みに失敗しました。\n" + err.message);
        } finally {
          setIsLoading(false);
        }
      };

      const refreshLibrary = async () => {
        setIsLoading(true);
        try {
          const list = await getAllProjectsMeta();
          setLocalProjects(list);
        } catch (e) { console.error(e); }
        finally { setIsLoading(false); }
      };

      // Merge Local and Remote Projects
      const projectList = React.useMemo(() => {
        const locals = localProjects.map(p => ({ ...p, isLocal: true }));
        const remotes = remoteProjects
          .filter(r => !localProjects.find(l => l.id === r.id))
          .map(r => ({
            ...r,
            isRemote: true,
            isLocal: false,
            updatedAt: new Date().toISOString(),
            pagesCount: '-',
            hasAudio: r.audio && r.audio.length > 0
          }));
        return [...locals, ...remotes].sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
      }, [localProjects, remoteProjects]);



      // --- Helper: Blob/Url Handling ---
      const blobUrlToBlob = async (blobUrl) => {
        const response = await fetch(blobUrl);
        return await response.blob();
      };

      const blobUrlToBase64 = async (blobUrl) => {
        const blob = await blobUrlToBlob(blobUrl);
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      };

      const loadServerAudio = async (url, name) => {
        if (!url) return;
        if (audioSrc && !confirm("音声を切り替えますか？")) return;

        setIsLoading(true);
        try {
          const res = await fetch(url);
          if (!res.ok) throw new Error("Fetch failed");
          const blob = await res.blob();
          const blobUrl = URL.createObjectURL(blob);
          setAudioSrc(blobUrl);
          setAudioFileName(name);
          setCurrentTime(0);
          if (audioRef.current) {
            audioRef.current.currentTime = 0;
          }
        } catch (e) {
          console.error(e);
          alert("音声ファイルの読み込みに失敗しました。");
        } finally {
          setIsLoading(false);
        }
      };

      // --- Actions ---
      const startNewProject = () => {
        setProjectId(Date.now().toString()); // Temporary ID
        setProjectTitle("無題のプロジェクト");
        setPages([]);
        setMarkers([]);
        setAudioSrc(null);
        setAudioFileName(null);
        setCurrentPageIndex(0);
        setMode('edit');
      };

      const handleOpenProject = async (id) => {
        setIsLoading(true);
        try {
          const project = await getProjectFromDB(id);
          if (!project) throw new Error("Project not found");

          // Restore Pages (Blob -> Blob URL)
          const restoredPages = project.pages.map(p => ({
            ...p,
            src: URL.createObjectURL(p.blob)
          }));

          setProjectId(project.id);
          setProjectTitle(project.title);
          setPages(restoredPages);
          setMarkers(project.markers);
          setCurrentAudioConfig(project.audioConfig || null); // Restore Config

          // Restore Audio
          if (project.audio) {
            setAudioSrc(URL.createObjectURL(project.audio.blob));
            setAudioFileName(project.audio.name);
          } else if (project.audioConfig && project.audioConfig.tracks && project.audioConfig.tracks.length > 0) {
            // Auto-load first track from config
            const t = project.audioConfig.tracks[0];
            const url = `${project.audioConfig.baseDir}/${t.file}`;
            await loadServerAudio(url, t.label);
          } else {
            setAudioSrc(null);
            setAudioFileName(null);
          }

          setCurrentPageIndex(0);
          setMode('practice');
        } catch (e) {
          console.error("Failed to open project", e);
          alert("プロジェクトを開けませんでした。");
        } finally {
          setIsLoading(false);
        }
      };

      const handleDeleteProject = async (id, e) => {
        e.stopPropagation();
        if (!window.confirm("このプロジェクトを削除してもよろしいですか？\nこの操作は取り消せません。")) return;

        setIsLoading(true);
        try {
          await deleteProjectFromDB(id);
          await refreshLibrary();
        } catch (e) {
          console.error("Failed to delete", e);
          alert("削除に失敗しました。");
        } finally {
          setIsLoading(false);
        }
      };

      const handleSaveToDB = async () => {
        if (pages.length === 0 && !audioSrc) {
          alert("保存するデータがありません。");
          return;
        }

        const titleInput = prompt("プロジェクト名を入力してください", projectTitle);
        if (titleInput === null) return;
        const finalTitle = titleInput || "無題のプロジェクト";
        setProjectTitle(finalTitle);

        setIsLoading(true);
        try {
          const pagesForDB = await Promise.all(pages.map(async (p) => ({
            id: p.id,
            name: p.name,
            blob: await blobUrlToBlob(p.src)
          })));

          let audioForDB = null;
          if (audioSrc) {
            audioForDB = {
              name: audioFileName,
              blob: await blobUrlToBlob(audioSrc)
            };
          }

          const projectData = {
            id: projectId,
            title: finalTitle,
            updatedAt: new Date().toISOString(),
            markers,
            pages: pagesForDB,
            audio: audioForDB
          };

          await saveProjectToDB(projectData);
          alert("データベースに保存しました！");
          await refreshLibrary();
        } catch (e) {
          console.error("Save failed", e);
          alert("保存に失敗しました。");
        } finally {
          setIsLoading(false);
        }
      };

      // JSON Export (Backup)
      const handleExportJSON = async () => {
        if (pages.length === 0 && !audioSrc) return;
        setIsLoading(true);
        try {
          const serializedPages = await Promise.all(pages.map(async (p) => ({
            ...p,
            src: await blobUrlToBase64(p.src)
          })));

          let serializedAudio = null;
          if (audioSrc) {
            serializedAudio = {
              name: audioFileName,
              data: await blobUrlToBase64(audioSrc)
            };
          }

          const projectData = {
            version: "1.0",
            timestamp: new Date().toISOString(),
            title: projectTitle,
            markers,
            pages: serializedPages,
            audio: serializedAudio
          };

          const jsonString = JSON.stringify(projectData);
          const blob = new Blob([jsonString], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `${projectTitle.replace(/\s+/g, '_')}_Backup.json`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        } catch (e) {
          console.error(e);
          alert("エクスポート失敗");
        } finally {
          setIsLoading(false);
        }
      };

      // --- File Processing ---
      const processFiles = useCallback((files) => {
        const imageFiles = [];
        let audioFile = null;

        files.forEach(file => {
          if (file.type.startsWith('image/')) {
            imageFiles.push(file);
          } else if (file.type.startsWith('audio/')) {
            audioFile = file;
          } else if (file.name.endsWith('.json')) {
            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                const data = JSON.parse(e.target.result);
                alert("JSONファイルはライブラリ画面の「インポート」機能、または現在編集中なら読み込みボタンを使用してください。");
              } catch (err) { console.error(err); }
            };
            reader.readAsText(file);
          }
        });

        if (imageFiles.length > 0) {
          imageFiles.sort((a, b) => a.name.localeCompare(b.name));
          const newPages = imageFiles.map(file => ({
            id: Date.now() + Math.random().toString(36).substr(2, 9),
            src: URL.createObjectURL(file),
            name: file.name || "Pasted Image"
          }));
          setPages(prev => [...prev, ...newPages]);
        }

        if (audioFile) {
          setAudioSrc(URL.createObjectURL(audioFile));
          setAudioFileName(audioFile.name);
        }
      }, []);

      // --- Interaction & Events ---
      const handleMarkerMouseDown = (e, marker, type) => {
        if (mode !== 'edit') return;
        e.stopPropagation();
        setInteractionState({
          type,
          markerId: marker.id,
          startX: e.clientX,
          startY: e.clientY,
          initialData: { x: marker.x, y: marker.y, width: marker.width, height: marker.height }
        });
        setSelectedMarkerId(marker.id);
      };

      useEffect(() => {
        const handleMouseMove = (e) => {
          if (!interactionState.type || !imageContainerRef.current) return;
          const rect = imageContainerRef.current.getBoundingClientRect();
          const deltaX_px = e.clientX - interactionState.startX;
          const deltaY_px = e.clientY - interactionState.startY;
          const deltaX_pct = (deltaX_px / rect.width) * 100;
          const deltaY_pct = (deltaY_px / rect.height) * 100;

          setMarkers(prev => prev.map(m => {
            if (m.id !== interactionState.markerId) return m;
            if (interactionState.type === 'move') {
              return {
                ...m,
                x: interactionState.initialData.x + deltaX_pct,
                y: interactionState.initialData.y + deltaY_pct
              };
            } else if (interactionState.type === 'resize') {
              return {
                ...m,
                width: Math.max(2, interactionState.initialData.width + deltaX_pct),
                height: Math.max(2, interactionState.initialData.height + deltaY_pct)
              };
            }
            return m;
          }));
        };
        const handleMouseUp = () => {
          if (interactionState.type) {
            setInteractionState({ type: null, markerId: null, startX: 0, startY: 0, initialData: null });
          }
        };
        if (interactionState.type) {
          window.addEventListener('mousemove', handleMouseMove);
          window.addEventListener('mouseup', handleMouseUp);
        }
        return () => {
          window.removeEventListener('mousemove', handleMouseMove);
          window.removeEventListener('mouseup', handleMouseUp);
        };
      }, [interactionState]);

      const handleDragOver = (e) => { e.preventDefault(); setIsDraggingOver(true); };
      const handleDragLeave = (e) => { e.preventDefault(); setIsDraggingOver(false); };
      const handleDrop = (e) => {
        e.preventDefault();
        setIsDraggingOver(false);
        processFiles(Array.from(e.dataTransfer.files));
      };

      useEffect(() => {
        const handlePaste = (e) => {
          if (mode === 'library') return;
          if (e.clipboardData && e.clipboardData.items) {
            const items = e.clipboardData.items;
            const files = [];
            for (let i = 0; i < items.length; i++) {
              if (items[i].type.indexOf('image') !== -1) {
                const blob = items[i].getAsFile();
                const file = new File([blob], `Pasted Image ${new Date().toLocaleTimeString()}`, { type: blob.type });
                files.push(file);
              }
            }
            if (files.length > 0) processFiles(files);
          }
        };
        window.addEventListener('paste', handlePaste);
        return () => window.removeEventListener('paste', handlePaste);
      }, [processFiles, mode]);

      // --- Navigation ---
      const goToNextPage = () => { if (currentPageIndex < pages.length - 1) setCurrentPageIndex(prev => prev + 1); };
      const goToPrevPage = () => { if (currentPageIndex > 0) setCurrentPageIndex(prev => prev - 1); };
      const deletePage = (index) => {
        const pageToDelete = pages[index];
        setMarkers(prev => prev.filter(m => m.pageId !== pageToDelete.id));
        const newPages = pages.filter((_, i) => i !== index);
        setPages(newPages);
        if (currentPageIndex >= newPages.length) setCurrentPageIndex(Math.max(0, newPages.length - 1));
      };

      // --- Marker Ops ---
      const addMarker = (e) => {
        if (mode !== 'edit' || !imageContainerRef.current || pages.length === 0) return;
        if (interactionState.type) return;
        const rect = imageContainerRef.current.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * 100;
        const y = ((e.clientY - rect.top) / rect.height) * 100;
        const currentPage = pages[currentPageIndex];
        const newMarker = {
          id: Date.now(), x, y, width: 10, height: 5, startTime: 0, endTime: 10,
          label: `Q${markers.length + 1}`, pageId: currentPage.id
        };
        setMarkers([...markers, newMarker]);
        setSelectedMarkerId(newMarker.id);
      };
      const updateMarker = (id, field, value) => setMarkers(markers.map(m => m.id === id ? { ...m, [field]: value } : m));
      const deleteMarker = (id) => {
        setMarkers(markers.filter(m => m.id !== id));
        if (selectedMarkerId === id) setSelectedMarkerId(null);
      };



      // Heuristic to map Marker Label to Audio Part
      // Heuristic to map Marker Label to Audio Part
      const getAudioInfoForMarker = (marker) => {
        if (!marker || !marker.label || !currentAudioConfig) return null;

        const match = marker.label.match(/(\d+)/);
        if (!match) return null;
        const num = parseInt(match[1], 10);

        // Find track that covers this number
        const track = currentAudioConfig.tracks.find(t => num >= t.range[0] && num <= t.range[1]);
        if (!track) return null;

        return {
          url: `${currentAudioConfig.baseDir}/${track.file}`,
          name: track.label
        };
      };

      const loadAudioToCache = async (url) => {
        if (audioCache.current[url]) return audioCache.current[url];

        setIsLoading(true);
        try {
          const res = await fetch(url);
          const blob = await res.blob();
          const blobUrl = URL.createObjectURL(blob);
          audioCache.current[url] = blobUrl;
          return blobUrl;
        } finally {
          setIsLoading(false);
        }
      };

      // --- Audio Ops ---
      const playSegment = async (marker) => {
        if (!audioRef.current) return;

        // 1. Page Navigation
        const targetPageIndex = pages.findIndex(p => p.id === marker.pageId);
        if (targetPageIndex !== -1 && targetPageIndex !== currentPageIndex) setCurrentPageIndex(targetPageIndex);

        // 2. Determine required audio
        const audioInfo = getAudioInfoForMarker(marker);
        let targetBlobUrl = audioSrc;
        let targetName = audioFileName;

        if (audioInfo) {
          // Ensure it is loaded
          if (!audioCache.current[audioInfo.url]) {
            targetBlobUrl = await loadAudioToCache(audioInfo.url);
          } else {
            targetBlobUrl = audioCache.current[audioInfo.url];
          }
          targetName = audioInfo.name;
        }

        // 3. Switch Audio if needed
        if (targetBlobUrl !== audioSrc) {
          setAudioSrc(targetBlobUrl);
          setAudioFileName(targetName);
          pendingPlayMarker.current = marker; // Queue play
          // The useEffect below will trigger play when src changes
        } else {
          // 4. Just Play
          audioRef.current.playbackRate = playbackRate;
          audioRef.current.pause();
          audioRef.current.currentTime = marker.startTime;
          setCurrentMarkerId(marker.id);
          audioRef.current.play().then(() => setIsPlaying(true)).catch(console.error);
        }
      };

      // Auto-play after audio switch
      useEffect(() => {
        if (pendingPlayMarker.current && audioRef.current && audioSrc) {
          const marker = pendingPlayMarker.current;
          pendingPlayMarker.current = null;

          audioRef.current.playbackRate = playbackRate;
          audioRef.current.currentTime = marker.startTime;
          setCurrentMarkerId(marker.id);
          audioRef.current.play().then(() => setIsPlaying(true)).catch(console.error);
        }
      }, [audioSrc]);

      const togglePlay = () => {
        if (!audioRef.current) return;
        audioRef.current.playbackRate = playbackRate;
        if (isPlaying) { audioRef.current.pause(); setIsPlaying(false); }
        else { audioRef.current.play(); setIsPlaying(true); }
      };
      const toggleSpeed = () => {
        const newRate = playbackRate === 1.0 ? 2.0 : 1.0;
        setPlaybackRate(newRate);
        if (audioRef.current) audioRef.current.playbackRate = newRate;
      };
      const seekRelative = (s) => {
        if (!audioRef.current) return;
        audioRef.current.currentTime = Math.min(Math.max(audioRef.current.currentTime + s, 0), duration);
        setCurrentTime(audioRef.current.currentTime);
      };
      useEffect(() => {
        const audio = audioRef.current;
        if (!audio) return;
        const handleTimeUpdate = () => {
          setCurrentTime(audio.currentTime);
          if (currentMarkerId && isPlaying) {
            const activeMarker = markers.find(m => m.id === currentMarkerId);
            if (activeMarker && audio.currentTime >= activeMarker.endTime) {
              audio.pause(); setIsPlaying(false); setCurrentMarkerId(null); audio.currentTime = activeMarker.startTime;
            }
          }
        };
        const handleLoadedMetadata = () => setDuration(audio.duration);
        audio.addEventListener('timeupdate', handleTimeUpdate);
        audio.addEventListener('loadedmetadata', handleLoadedMetadata);
        audio.playbackRate = playbackRate;
        return () => {
          audio.removeEventListener('timeupdate', handleTimeUpdate);
          audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
        };
      }, [currentMarkerId, isPlaying, markers, playbackRate]);

      const formatTime = (time) => {
        if (isNaN(time)) return "0:00";
        const m = Math.floor(time / 60);
        const s = Math.floor(time % 60);
        const ms = Math.floor((time % 1) * 10);
        return `${m}:${s.toString().padStart(2, '0')}.${ms}`;
      };

      const currentPage = pages[currentPageIndex];
      const currentMarkers = currentPage ? markers.filter(m => m.pageId === currentPage.id) : [];
      if (mode === 'library') {
        return (
          <div className="min-h-screen bg-gray-50 flex flex-col items-center p-8">
            <div className="w-full max-w-4xl space-y-8">
              <div className="flex items-center gap-3 mb-8">
                <div className="bg-blue-600 text-white p-3 rounded-xl shadow-lg">
                  <Database size={32} />
                </div>
                <div>
                  <h1 className="text-3xl font-bold text-gray-800">英検リスニング演習 Studio {isStudentMode && <span className="bg-green-100 text-green-700 text-sm px-2 py-1 rounded-full ml-2 align-middle">生徒モード</span>}</h1>
                  <p className="text-gray-500">ローカルデータベースモード</p>
                </div>
              </div>

              {/* Action Cards */}
              {!isStudentMode ? (
                <div className="grid md:grid-cols-2 gap-4">
                  <button
                    onClick={startNewProject}
                    className="bg-white p-6 rounded-xl shadow-sm border-2 border-dashed border-blue-200 hover:border-blue-400 hover:bg-blue-50 transition flex flex-col items-center justify-center gap-4 group h-48"
                  >
                    <div className="w-16 h-16 bg-blue-100 rounded-full flex items-center justify-center text-blue-600 group-hover:scale-110 transition">
                      <PlusCircle size={32} />
                    </div>
                    <div className="text-center">
                      <h3 className="font-bold text-lg text-blue-900">新規プロジェクト作成</h3>
                      <p className="text-sm text-gray-500">画像と音声から新しい演習を作成</p>
                    </div>
                  </button>

                  {/* Share Card */}
                  <div className="bg-white p-6 rounded-xl shadow-md border flex flex-col justify-between h-48">
                    <div>
                      <h3 className="font-bold text-lg text-gray-800 flex items-center gap-2"><CheckCircle size={20} /> 生徒用リンク</h3>
                      <p className="text-gray-500 text-sm mt-2">
                        生徒に配布するための「編集機能なし」モードのリンクをコピーします。
                      </p>
                    </div>
                    <button onClick={() => {
                      const url = new URL(window.location.href);
                      url.searchParams.set('student', 'true');
                      navigator.clipboard.writeText(url.toString());
                      alert("生徒用リンクをコピーしました！\n" + url.toString());
                    }} className="w-full bg-blue-600 text-white py-2 rounded-lg hover:bg-blue-700 transition">
                      リンクをコピー
                    </button>
                  </div>
                </div>
              ) : (
                /* Student Mode Actions */
                <div className="bg-green-50 border border-green-200 p-6 rounded-xl text-green-800">
                  <h3 className="font-bold flex items-center gap-2"><CheckCircle size={20} /> 学習を開始しましょう</h3>
                  <p className="text-sm mt-1 mb-4">以下のリストからプロジェクトを選んでください。</p>
                  <button onClick={() => fetchRemoteCatalog()} className="text-xs bg-white hover:bg-green-100 text-green-700 px-3 py-1.5 rounded transition border border-green-300">
                    ↻ カタログ更新
                  </button>
                </div>
              )}

              {/* Project List */}
              <div className="space-y-4">
                <h2 className="text-xl font-bold text-gray-800 flex items-center gap-2">
                  <Clock size={20} /> 学習プロジェクト
                </h2>

                {isLoading ? (
                  <div className="text-center py-12 text-gray-400 animate-pulse">読み込み中...</div>
                ) : projectList.length > 0 ? (
                  <div className="bg-white rounded-xl shadow-sm border border-gray-200 divide-y">
                    {projectList.map(project => (
                      <div key={project.id} onClick={() => project.isLocal ? handleOpenProject(project.id) : importRemoteProject(project)}
                        className="p-4 flex items-center justify-between hover:bg-gray-50 cursor-pointer transition group">
                        <div className="flex items-center gap-4">
                          <div className="w-12 h-12 bg-gray-100 rounded-lg flex items-center justify-center text-gray-400">
                            <FileText size={24} />
                          </div>
                          <div>
                            <h3 className="font-bold text-gray-800 group-hover:text-blue-600 transition">{project.title}</h3>
                            <div className="flex items-center gap-4 text-xs text-gray-500 mt-1">
                              <span className="flex items-center gap-1"><Layers size={12} /> {project.pagesCount} pages</span>
                              <span className="flex items-center gap-1"><Volume2 size={12} /> {project.hasAudio ? 'Audio OK' : 'No Audio'}</span>
                              <span>Updated: {new Date(project.updatedAt).toLocaleString()}</span>
                            </div>
                          </div>
                        </div>
                        {!isStudentMode && (
                          <button
                            onClick={(e) => handleDeleteProject(project.id, e)}
                            className="p-2 text-gray-300 hover:text-red-500 hover:bg-red-50 rounded-full transition"
                            title="削除"
                          >
                            <Trash2 size={20} />
                          </button>
                        )}
                      </div>
                    ))}
                  </div>
                ) : (
                  <div className="text-center py-12 bg-white rounded-xl border border-gray-200 text-gray-400">
                    まだプロジェクトがありません
                  </div>
                )}
              </div>
            </div>
          </div>
        );
      }

      // --- RENDER: EDITOR / PRACTICE MODE ---
      return (
        <div className="flex flex-col h-screen bg-gray-50 text-gray-800 font-sans" onDragOver={handleDragOver} onDragLeave={handleDragLeave} onDrop={handleDrop}>
          {isLoading && <div className="fixed inset-0 bg-black/50 z-[100] flex items-center justify-center text-white"><div className="text-xl font-bold animate-pulse">処理中...</div></div>}
          {isDraggingOver && <div className="fixed inset-0 bg-blue-500/90 z-50 flex items-center justify-center text-white backdrop-blur-sm"><div className="text-center p-8 border-4 border-dashed border-white/50 rounded-xl"><Upload size={64} className="mx-auto mb-4" /><h2 className="text-3xl font-bold">ファイルをドロップ</h2><p className="mt-2 text-blue-100">画像・音声を追加</p></div></div>}

          {/* Header */}
          <header className="bg-blue-600 text-white p-3 shadow-md flex justify-between items-center z-10 shrink-0">
            <div className="flex items-center gap-4">
              <button onClick={() => setMode('library')} className="hover:bg-blue-700 p-2 rounded-lg transition" title="ライブラリに戻る">
                <ArrowLeft size={24} />
              </button>
              <div className="flex items-center gap-2">
                <Volume2 className="w-6 h-6" />
                <h1 className="text-lg font-bold hidden sm:block truncate max-w-[200px]">{projectTitle}</h1>
              </div>
            </div>
            {pages.length > 0 && (
              <div className="flex items-center gap-2 bg-blue-700/50 px-3 py-1 rounded-full mx-2">
                <button onClick={goToPrevPage} disabled={currentPageIndex === 0} className="p-1 hover:bg-blue-600 rounded-full disabled:opacity-30 transition"><ChevronLeft size={20} /></button>
                <span className="text-sm font-mono min-w-[80px] text-center">Page {currentPageIndex + 1} / {pages.length}</span>
                <button onClick={goToNextPage} disabled={currentPageIndex === pages.length - 1} className="p-1 hover:bg-blue-600 rounded-full disabled:opacity-30 transition"><ChevronRight size={20} /></button>
              </div>
            )}
            <div className="flex items-center gap-2 shrink-0">
              {!isStudentMode && (
                <div className="flex bg-blue-700 rounded-lg p-1 mr-2">
                  <button onClick={handleExportJSON} className="p-1.5 text-blue-100 hover:text-white hover:bg-blue-600 rounded" title="バックアップ(JSON)"><Download size={18} /></button>
                  <button onClick={handleSaveToDB} className="p-1.5 text-blue-100 hover:text-white hover:bg-blue-600 rounded flex items-center gap-1 px-2" title="DB保存"><Save size={18} /><span className="text-xs font-bold">保存</span></button>
                </div>
              )}
              <div className="flex bg-blue-700 rounded-lg p-1">
                {!isStudentMode && (
                  <button onClick={() => setMode('edit')} className={`px-3 py-1.5 rounded-md text-sm font-medium transition-all ${mode === 'edit' ? 'bg-white text-blue-700 shadow' : 'text-blue-100 hover:text-white'}`}>編集</button>
                )}
                <button onClick={() => { setSelectedMarkerId(null); setMode('practice'); }} className={`px-3 py-1.5 rounded-md text-sm font-medium transition-all ${mode === 'practice' || isStudentMode ? 'bg-white text-blue-700 shadow' : 'text-blue-100 hover:text-white'}`}>演習</button>
              </div>
            </div>
          </header>

          <div className="flex-1 flex overflow-hidden">
            <div className="flex-1 bg-gray-200 overflow-auto relative">
              <div className="min-h-full p-4 sm:p-8 flex justify-center items-start">
                {currentPage ? (
                  <div className="relative shadow-xl bg-white select-none transition-all duration-300" style={{ maxWidth: '100%', width: 'fit-content' }}>
                    <img ref={imageContainerRef} src={currentPage.src} alt={`Page ${currentPageIndex + 1}`} className="max-w-full h-auto block cursor-crosshair" onClick={addMarker} draggable={false} />
                    {currentMarkers.map((marker) => (
                      <div key={marker.id} onMouseDown={(e) => handleMarkerMouseDown(e, marker, 'move')} onClick={(e) => { e.stopPropagation(); if (mode === 'practice') playSegment(marker); else setSelectedMarkerId(marker.id); }}
                        className={`absolute border-2 flex items-center justify-center transition-colors ${mode === 'edit' ? (selectedMarkerId === marker.id ? 'border-blue-500 bg-blue-500/20 z-20 cursor-move' : 'border-blue-300 bg-blue-300/10 hover:bg-blue-300/20 z-10 cursor-pointer') : (currentMarkerId === marker.id ? 'border-green-500 bg-green-500/30 z-10 cursor-pointer' : 'border-transparent hover:bg-blue-100/30 hover:border-blue-300/50 cursor-pointer')}`}
                        style={{ left: `${marker.x}%`, top: `${marker.y}%`, width: `${marker.width || 10}%`, height: `${marker.height || 5}%` }}>
                        <span className={`text-xs font-bold px-1 rounded ${mode === 'edit' && selectedMarkerId === marker.id ? 'bg-blue-600 text-white' : mode === 'practice' && currentMarkerId === marker.id ? 'bg-green-600 text-white' : 'bg-white/80 text-gray-700'}`}>{marker.label}</span>
                        {mode === 'edit' && selectedMarkerId === marker.id && (<div onMouseDown={(e) => handleMarkerMouseDown(e, marker, 'resize')} className="absolute bottom-0 right-0 w-4 h-4 bg-blue-500 cursor-nwse-resize z-30 flex items-center justify-center" style={{ transform: 'translate(50%, 50%)' }}><Maximize2 size={8} className="text-white transform rotate-90" /></div>)}
                      </div>
                    ))}
                    <div className="absolute top-2 right-2 bg-black/50 text-white text-xs px-2 py-1 rounded backdrop-blur-sm pointer-events-none">Page {currentPageIndex + 1}</div>
                  </div>
                ) : (
                  <div className="flex flex-col items-center justify-center text-gray-400 space-y-4 max-w-md text-center my-auto h-[80vh]">
                    <div className="p-6 border-2 border-dashed border-gray-300 rounded-xl bg-gray-100">
                      <Upload size={48} className="mx-auto mb-2 text-gray-400" />
                      <p className="text-lg font-bold text-gray-600">ファイルをドロップ</p>
                      <p className="text-sm">画像・音声をドラッグ＆ドロップ</p>
                      <p className="text-xs text-blue-500 mt-2 font-semibold">Tip: スクショ(Ctrl+V)も使えます</p>
                    </div>
                  </div>
                )}
              </div>
            </div>

            <div className="w-80 bg-white border-l border-gray-200 flex flex-col shadow-xl z-20 shrink-0">
              <div className="flex-1 overflow-y-auto p-4 custom-scrollbar">
                {mode === 'edit' && (
                  <div className="space-y-6">
                    <div className="space-y-2">
                      <h3 className="font-bold text-gray-800 text-sm flex items-center gap-2"><Layers size={16} /> ページ管理</h3>
                      {pages.length > 0 ? (
                        <div className="bg-gray-50 border rounded-lg overflow-hidden">
                          {pages.map((page, idx) => (
                            <div key={page.id} onClick={() => setCurrentPageIndex(idx)} className={`flex items-center gap-2 p-2 cursor-pointer border-b last:border-0 hover:bg-gray-100 ${idx === currentPageIndex ? 'bg-blue-50 text-blue-700' : 'text-gray-600'}`}>
                              <div className="w-5 text-xs text-center font-bold text-gray-400">{idx + 1}</div>
                              <FileText size={14} />
                              <span className="text-xs truncate flex-1">{page.name}</span>
                              <button onClick={(e) => { e.stopPropagation(); deletePage(idx); }} className="text-gray-400 hover:text-red-500 p-1"><X size={14} /></button>
                            </div>
                          ))}
                        </div>
                      ) : <div className="text-xs text-gray-500 italic p-2 border border-dashed rounded text-center">画像を追加してください</div>}
                    </div>
                    <div>
                      <h3 className="font-bold text-gray-800 mb-2 border-b pb-1 text-sm">マーカー設定</h3>
                      {pages.length === 0 ? <p className="text-xs text-gray-400">まずページを追加</p> : selectedMarkerId ? (
                        (() => {
                          const m = markers.find(mark => mark.id === selectedMarkerId);
                          if (!m) return null;
                          return (
                            <div className="bg-white border border-gray-200 rounded-lg p-3 shadow-sm space-y-3 animate-fadeIn">
                              <div className="flex justify-between items-center"><span className="font-bold text-blue-600 text-sm">編集中のマーカー</span><button onClick={() => deleteMarker(m.id)} className="text-red-500 hover:text-red-700 p-1"><Trash2 size={16} /></button></div>
                              <div className="space-y-2"><label className="text-xs text-gray-500 block">ラベル</label><input type="text" value={m.label} onChange={(e) => updateMarker(m.id, 'label', e.target.value)} className="w-full border rounded px-2 py-1 text-sm" /></div>
                              <div className="grid grid-cols-2 gap-2">
                                <div><label className="text-xs text-gray-500 block">開始</label><input type="number" step="0.1" value={m.startTime} onChange={(e) => updateMarker(m.id, 'startTime', parseFloat(e.target.value))} className="w-full border rounded px-2 py-1 text-sm font-mono" /><button onClick={() => audioRef.current && updateMarker(m.id, 'startTime', audioRef.current.currentTime)} className="mt-1 text-xs bg-blue-50 hover:bg-blue-100 text-blue-700 border border-blue-200 w-full py-1 rounded">現在位置</button></div>
                                <div><label className="text-xs text-gray-500 block">終了</label><input type="number" step="0.1" value={m.endTime} onChange={(e) => updateMarker(m.id, 'endTime', parseFloat(e.target.value))} className="w-full border rounded px-2 py-1 text-sm font-mono" /><button onClick={() => audioRef.current && updateMarker(m.id, 'endTime', audioRef.current.currentTime)} className="mt-1 text-xs bg-red-50 hover:bg-red-100 text-red-700 border border-red-200 w-full py-1 rounded">現在位置</button></div>
                              </div>
                              <button onClick={() => playSegment(m)} className="w-full mt-2 bg-green-50 text-green-700 border border-green-200 py-1 rounded text-sm hover:bg-green-100 flex items-center justify-center gap-1"><Play size={14} /> テスト再生</button>
                            </div>
                          )
                        })()
                      ) : <div className="text-center py-6 text-gray-400 bg-gray-50 rounded border border-dashed"><PlusCircle className="mx-auto mb-2 opacity-50" /><p className="text-xs">画像をクリックして<br />問題を追加</p></div>}
                    </div>
                  </div>
                )}
                {mode === 'practice' && (
                  <div className="space-y-4">
                    <div className="bg-green-50 border border-green-200 rounded-lg p-3 text-green-800"><h3 className="font-bold flex items-center gap-2 mb-1 text-sm"><CheckCircle size={16} /> 演習モード</h3></div>
                    <div className="bg-white border rounded-lg overflow-hidden">
                      <div className="bg-gray-100 px-3 py-2 border-b text-xs font-bold text-gray-500 flex justify-between items-center"><span>問題リスト</span><span className="font-normal text-gray-400">{markers.length}問</span></div>
                      <div className="max-h-[60vh] overflow-y-auto">
                        {pages.map((page, pIdx) => {
                          const pageMarkers = markers.filter(m => m.pageId === page.id).sort((a, b) => a.id - b.id);
                          if (pageMarkers.length === 0) return null;
                          return (
                            <div key={page.id}>
                              <div className="bg-gray-50 px-4 py-1 text-xs font-bold text-gray-400 uppercase tracking-wider border-b border-t border-gray-100 sticky top-0">Page {pIdx + 1}</div>
                              {pageMarkers.map(m => (
                                <button key={m.id} onClick={() => playSegment(m)} className={`w-full text-left px-4 py-2 border-b last:border-0 flex justify-between items-center hover:bg-gray-50 transition ${currentMarkerId === m.id ? 'bg-blue-50 text-blue-700 font-bold border-l-4 border-l-blue-500' : 'text-gray-700 border-l-4 border-l-transparent'}`}>
                                  <span className="text-sm">{m.label}</span><span className="text-xs text-gray-400 font-mono">{formatTime(m.startTime)}</span>
                                </button>
                              ))}
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </div>
          </div>

          <div className="bg-white border-t border-gray-200 p-4 z-30 shrink-0 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.1)]">
            <div className="max-w-screen-2xl mx-auto space-y-2">
              <div className="relative group w-full"><input type="range" min={0} max={duration || 100} step="0.1" value={currentTime} onChange={(e) => { const time = parseFloat(e.target.value); if (audioRef.current) audioRef.current.currentTime = time; setCurrentTime(time); }} disabled={!audioSrc} className="w-full h-4 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600 hover:h-5 transition-all disabled:opacity-50" /></div>
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-4">
                  <button onClick={() => seekRelative(-5)} disabled={!audioSrc} className="w-8 h-8 rounded-full bg-gray-200 text-gray-700 flex items-center justify-center hover:bg-gray-300 transition shadow-sm disabled:opacity-50" title="5秒戻る"><RotateCcw size={16} /></button>
                  <button onClick={togglePlay} disabled={!audioSrc} className="w-10 h-10 rounded-full bg-blue-600 text-white flex items-center justify-center hover:bg-blue-700 transition shadow-sm disabled:bg-gray-400">{isPlaying ? <Pause size={20} /> : <Play size={20} />}</button>
                  <button onClick={() => seekRelative(5)} disabled={!audioSrc} className="w-8 h-8 rounded-full bg-gray-200 text-gray-700 flex items-center justify-center hover:bg-gray-300 transition shadow-sm disabled:opacity-50" title="5秒進む"><RotateCw size={16} /></button>
                  <button onClick={toggleSpeed} disabled={!audioSrc} className="h-8 px-2 rounded-lg bg-gray-100 border border-gray-300 text-gray-700 flex items-center justify-center gap-1 hover:bg-gray-200 transition text-xs font-bold disabled:opacity-50" title="再生速度切替"><Gauge size={14} />{playbackRate.toFixed(1)}x</button>
                  <div className="flex flex-col justify-center h-10 border-l pl-4 ml-2">
                    <span className="text-[10px] font-bold text-gray-400 uppercase tracking-wider leading-none">Audio</span>
                    <div className="flex items-center gap-2">
                      <span className="text-sm font-medium text-gray-700 truncate max-w-[150px] sm:max-w-xs leading-tight" title={audioFileName}>{audioFileName || "No Audio"}</span>
                      <select
                        onChange={(e) => {
                          const val = e.target.value;
                          if (!val) return;
                          if (currentAudioConfig) {
                            const track = currentAudioConfig.tracks.find(t => `${currentAudioConfig.baseDir}/${t.file}` === val);
                            if (track) loadServerAudio(val, track.label);
                          } else if (typeof SERVER_ASSETS !== 'undefined') {
                            const opt = SERVER_ASSETS.audio.find(a => a.url === val);
                            if (opt) loadServerAudio(opt.url, opt.name);
                          }
                          e.target.value = "";
                        }}
                        className="text-xs border rounded bg-gray-50 max-w-[80px] opacity-70 hover:opacity-100 transition"
                      >
                        <option value="">Load...</option>
                        {typeof SERVER_ASSETS !== 'undefined' && SERVER_ASSETS.audio.map(a => <option key={a.url} value={a.url}>{a.name}</option>)}
                        {currentAudioConfig && currentAudioConfig.tracks.map(t => (
                          <option key={t.file} value={`${currentAudioConfig.baseDir}/${t.file}`}>{t.label}</option>
                        ))}
                      </select>
                    </div>
                  </div>
                </div>
                <div className="text-xl font-mono text-gray-700 font-bold">{formatTime(currentTime)} <span className="text-sm text-gray-400 font-normal">/ {formatTime(duration)}</span></div>
              </div>
            </div>
            <audio ref={audioRef} src={audioSrc} />
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>

</html>